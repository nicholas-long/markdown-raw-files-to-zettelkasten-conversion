#!/bin/bash
export ZET_CMD_IMPLEMENTATION=20221006032546

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
# the SCRIPT_DIR of symlinked zc command will be the root of the zettelkasten folder

# parse args with case statement
VERBOSE=0
makeedit=0
while [[ $# -gt 0 ]]; do
  case $1 in
    -e|--edit)
      makeedit=1
      ;;
    -f|--file|--forwarding-address)
      shift
      filearg="$1"
      ;;
    -q|--query)
      shift # pop arg
      query="$1"
      ;;
    -t|--title|--target)
      shift # pop arg
      title="$1"
      ;;
    -v|--verbose)
      VERBOSE=1
      ;;
    -h|--help)
      echo "Usage: $0 action [ options ]"
      echo "| action: [ new, rm, search, print, refs, preview ]"
      echo "Options:"
      cat "$0" | grep '^\s\+-.|--.*' | sed 's/)$//'
      exit 1
      ;;
    *)
      if [ -z "$action" ]; then
        action="$1"
      elif [ $action == "print" ]; then
        bat --paging=never zet/$1/README.md
      elif [ $action == "unlink" ]; then
        arg="$1"
        arg2="$2"
        shift
      else
        arg="$1"
      fi
      #TODO: break for certain specific actions to keep rest of args for later
      ;;
  esac
  shift
done

echo "$action $title $arg $filearg" > /dev/stderr
case $action in
  n|new)
    echo "making new"
    id=$(date -u +%Y%m%d%H%M%S)
    mkdir -p zet/$id
    filepath="zet/$id/README.md"
    cp zettel-template "$filepath"
    if [ ! -z "$title" ]; then
      sed -i "s|{{title}}|$title|" "$filepath"
    fi
    sed -i "s|00000000000000|$id|" "$filepath"
    if [ 0 != "$makeedit" ]; then
      nvim "$filepath"
    fi
    echo "Created Zettel ID $id"
    ;;
  spawn)
    ids=$(mktemp)
    $0 find -q "$query" 2>/dev/null | fzf -m | awk '
      {
        split($1,arr,"/")
        id = arr[2]
        print id
      }
      ' > $ids
    newid=$($0 new -t "$query" | awk '/Created Zettel ID/ { print $NF }')
    sed -i '/{{ref}}/d' zet/$newid/README.md # remove template ref stub
    for link in $(cat $ids); do
      $0 addref -t "$newid" "$link"
    done
    rm $ids
    echo "spawned new $newid" > /dev/stderr
    nvim zet/$newid/README.md
    ;;
  enum)
    #TODO: join tags with related tags in enum
    find zet -name README.md | xargs awk '
      BEGIN { OFS="\t" }
      FNR == 1 {
        gsub(/^# +/,"")
        head = $0
      }
      { last = $0 }
      BEGINFILE {
        if (last) print lastfilename, head, last
        lastfilename = FILENAME
      }
    '
    ;;
  refs)
    awk '
      BEGIN {
        for (n = 1; n < ARGC; n++) {
          if (ARGV[n] ~ /^[0-9]+$/) {
            ARGV[n] = "zet/" ARGV[n] "/README.md"
          }
        }
      }
      BEGINFILE { refs = 0 }
      #refs && /^ *$/ { nextfile }
      refs && /^- [0-9]+ *$/ { print $2 } # print un-enriched IDs in list
      refs && /^- \[[0-9]+\]/ {
        gsub(/^- +/,"")
        gsub(/^\[/,"")
        gsub(/\].*/,"")
        print
      }
      /^# [Rr]elated/ { refs = 1 }
    ' $arg
    ;;
  search) # fuzzy search with optional content filter
    if [ -z "$query" ]; then
      query="$arg"
    fi
    $0 find -q "$query" | fzf -m --preview="$0 preview -f {} 2>/dev/null"
    ;;
  find) # full content search
    if [ -z "$query" ]; then
      query="$arg"
    fi
    find zet -name README.md | xargs grep "$query" | awk -F ':' '
      BEGIN { OFS="\t" }
      !seen[$1]++ {
        command = "head -n 1 " $1
        command | getline heading
        close(command)
        gsub(/^# /, "", heading)
        outkw = ""
        for (n = 2; n <= NF; n++){
          if (outkw) outkw = outkw " "
          outkw = outkw $n
        }
        print $1, heading, outkw
      }
      '
    ;;
  preview)
    if [ ! -z "$filearg" ]; then
      filearg=$(echo $filearg | awk '{print $1}')
      bat --color=always "$filearg"
    fi
    ;;
  unlink)
    #arg arg2
    echo "unlinking $arg $arg2"
    [ -f "zet/$arg2/README.md" ] && sed -i "/$arg/d" zet/$arg2/README.md
    [ -f "zet/$arg/README.md" ] && sed -i "/$arg2/d" zet/$arg/README.md
    ;;
  rm)
    del_id="$arg"
    forward_id="$filearg"
    echo "$del_id -> $forward_id" > /dev/stderr
    if [ -z "$del_id" ]; then
      echo "unrecoverable error"
      exit 1
    fi
    if [ -z "$forward_id" ]; then
      echo "forwarding id is required to delete, pass with -f"
      exit 1
    fi
    find zet -name README.md | xargs sed -i "/$del_id/s/^.*$/- $forward_id/"
    rm -rf zet/$del_id
    #$0 enrich # don't do this automatically
    ;;
#  scanback)
#    sorted_refs=$(mktemp)
#    for zid in $(ls zet); do
#      export zid
#      $0 refs $zid 2>/dev/null | sort > $sorted_refs
#      for z2 in $(cat $sorted_refs); do
#        if [ -z "$z2" ]; then # skip if empty
#          continue
#        fi
#        count=$($0 refs $z2 2>/dev/null | awk '$0 == ENVIRON["zid"]' | wc -l)
#        if [ $count == 0 ]; then
#          echo "$zid -> $z2"
#        fi
#      done
#    done
#    rm $sorted_refs
#    ;;
  addref)
    target="$title"
    f="zet/$target/README.md"
    d="zet/$target"
    if [ -d "$d" ]; then
      if [ -f "$f" ]; then
        sed -i -e '/^# Related/a \
' -e "/^# Related/a - $arg" "$f"
      fi
    fi
    ;;
#  updateref)
#    tf=$(mktemp)
#    export prog="$0"
#    # TODO: replace scanback here with scanrefs
#    $0 scanback | awk 'NF == 3 {command = (ENVIRON["prog"] " addref -t " $3 " " $1); print command}' > $tf
#    if [ "$(wc -l $tf | awk '{print $1}')" != 0 ]; then # not zero lines then need to recurse
#      cat $tf
#      wc -l $tf
#      bash $tf
#      $0 enrich # recurse
#    fi
#    rm $tf
#    ;;
  enrich_links_single)
    zid="$arg"
    if [ -z $"zid" ]; then
      continue
    fi
    #get references
    cd zet/$zid
    cat README.md | awk '
    pr && /^#/ { exit }
    pr { print }
    /^# [Rr]elated/ { pr = 1 }
    ' > references
    awk '
    BEGIN { seen[""] = 0 }
    BEGINFILE { delete seen ; seen[""] = 0 }
    /^- [0-9]{14} *$/ {
      id = $2
      if (seen[id]) { next }
      seen[id] = 1
      "head -n 1 ../" id "/README.md" | getline heading
      gsub(/^# ?/,"",heading)
      if (system("test -f ../" id "/README.md") == 0) {
        print "- [" id "](/zet/" id "/README.md) " heading
      }
      next
    }
    /^- \[[0-9]{14}\]/ { # parse and reprint pretty references
      temp = $0
      gsub(/^- \[/, "", temp)
      gsub(/].*$/,"", temp)
      id = temp
      if (seen[id]) { next }
      seen[id] = 1
      "head -n 1 ../" id "/README.md" | getline heading
      gsub(/^# ?/,"",heading)
      if (system("test -f ../" id "/README.md") == 0) {
        print "- [" id "](/zet/" id "/README.md) " heading
      }
      next
    }
    { print }
    ' references > references_enriched

    { awk '/^# [Rr]elated/ { exit } { print }' README.md
    echo "# Related"
    cat references_enriched
    } > README_enriched.md

    # overwrite
    mv README_enriched.md README.md
    rm references
    rm references_enriched

    cd - > /dev/null
    ;;
  enrich)
    scanoutput=$(mktemp)
    find zet -name README.md | xargs zet/$ZET_CMD_IMPLEMENTATION/scanrefs > $scanoutput
    # get all tags
    tail -n 1 zet/*/README.md | awk '/^    #/' | sed -e 's/^    //g' -e 's/ /\n/g' | sort -u > all_tags

    # index tags
    rm -rf tagindex
    mkdir -p tagindex

    awk '
      BEGIN {
        ignore["assorted"] = 1
      }
      $1 == "tags" {
        for (n=3;n<=NF;n++) {
          t = $n
          gsub(/^#/,"",t)
          if (!(t in ignore)) {
            print "- [" $2 "](/zet/" $2 "/README.md)" > "tagindex/" t ".md"
          }
        }
      }
    ' $scanoutput

    # calling self recursively
    export prog="$0"

    # check backlinks
    awk '
      $1 == "backlink" {
        # link $2 to $3
        command = (ENVIRON["prog"] " addref -t " $2 " " $3)
        system ( command )
      }
      ' $scanoutput

    # rerun
    find zet -name README.md | xargs zet/$ZET_CMD_IMPLEMENTATION/scanrefs > $scanoutput

    # beautify links
    awk '$1 == "cleanup" {
      command = (ENVIRON["prog"] " enrich_links_single " $2)
      system ( command )
    }' $scanoutput

    awk '$1 == "dead" {
      print
      command = (ENVIRON["prog"] " unlink " $2 " " $3)
      system ( command )
    }' $scanoutput
    ;;
esac
