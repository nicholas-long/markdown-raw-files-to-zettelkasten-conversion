#!/bin/bash

#                        _        ___        ___   ___  
#   ___ ___  _   _  ___ | |_ ___ / _ \__  __/ _ \ / _ \ 
#  / __/ _ \| | | |/ _ \| __/ _ \ | | \ \/ / (_) | | | |
# | (_| (_) | |_| | (_) | ||  __/ |_| |>  < \__, | |_| |
#  \___\___/ \__, |\___/ \__\___|\___//_/\_\  /_/ \___/ 
#            |___/                                      

export ZET_CMD_IMPLEMENTATION=20221006032546
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
export prog="$0"
#TODO: use EDITOR env var

# run me as symlink from my directory or in somewhere with zet/
# the SCRIPT_DIR of symlinked zc command will be the root of the zettelkasten folder
[ -d zet ] || cd $SCRIPT_DIR && export prog="$SCRIPT_DIR/zc"

# parse args with case statement
VERBOSE=0
makeedit=0
while [[ $# -gt 0 ]]; do
  case $1 in
    -e|--edit)
      makeedit=1
      ;;
    -f|--file|--forwarding-address)
      shift
      filearg="$1"
      ;;
    -q|--query)
      shift # pop arg
      query="$1"
      ;;
    -t|--title|--target)
      shift # pop arg
      title="$1"
      ;;
    -r|--reference)
      shift # pop arg
      reference="$1"
      ;;
    -v|--verbose)
      VERBOSE=1
      ;;
    -h|--help)
      echo "Usage: $0 action [ options ]"
      echo "| action      : [ spawn, search, find, rm, print, enrich, new, refs, preview ]"
      echo "| | fzf       : [ spawn, search, vilink, viunlink ]"
      echo "| | scripting : [ find, addref, rm, print, enrich, new, refs, preview, enum, unlink, enrich_links_single, fixspaces ]"
      echo "Options:"
      cat "$prog" | grep '^\s\+-.|--.*' | sed 's/)$//'
      exit 1
      ;;
    *)
      if [ -z "$action" ]; then
        action="$1"
      elif [ $action == "print" ]; then
        bat --paging=never zet/$1/README.md
      elif [ $action == "unlink" ]; then
        arg="$1"
        arg2="$2"
        shift
      else
        arg="$1"
      fi
      #TODO: break for certain specific actions to keep rest of args for later
      ;;
  esac
  shift
done

echo "[diag] $action $title $arg $filearg" > /dev/stderr
case $action in
  n|new)
    id=$(date -u +%Y%m%d%H%M%S)
    mkdir -p zet/$id
    filepath="zet/$id/README.md"
    cp zettel-template "$filepath"
    if [ ! -z "$title" ]; then
      sed -i "s|{{title}}|$title|" "$filepath"
    fi
    if [ ! -z "$reference" ]; then
      $prog addref -t "$id" "$reference"
    fi
    sed -i "s|00000000000000|$id|" "$filepath"
    if [ 0 != "$makeedit" ]; then
      nvim "$filepath"
    fi
    echo "created zet ID $id"
    ;;
  s|spawn)
    ids=$(mktemp)
    $prog find -q "$query" 2>/dev/null | fzf -m "--prompt=$title >" | awk '
      {
        split($1,arr,"/")
        id = arr[2]
        print id
      }
      ' > $ids
    if [ -z "$title" ]; then
      title="$query"
    fi
    newid=$($prog new -t "$title" | awk '/[Cc]reated [Zz]ett?e?l? ID/ { print $NF }')
    echo "[diag] newid $newid" 2>/dev/stderr
    sed -i '/{{ref}}/d' zet/$newid/README.md # remove template ref stub
    for link in $(cat $ids); do
      $prog addref -t "$newid" "$link"
    done
    rm $ids
    echo "spawned new $newid" > /dev/stderr
    $prog fixspaces "$newid"
    nvim zet/$newid/README.md
    ;;
  enum)
    #TODO: join tags with related tags in enum
    find zet -name README.md | xargs awk '
      BEGIN { OFS="\t" }
      FNR == 1 {
        gsub(/^# +/,"")
        head = $0
      }
      { last = $0 }
      BEGINFILE {
        if (last) print lastfilename, head, last
        lastfilename = FILENAME
      }
    '
    ;;
  refs)
    awk '
      BEGIN {
        for (n = 1; n < ARGC; n++) {
          if (ARGV[n] ~ /^[0-9]+$/) {
            ARGV[n] = "zet/" ARGV[n] "/README.md"
          }
        }
      }
      BEGINFILE { refs = 0 }
      #refs && /^ *$/ { nextfile }
      refs && /^- [0-9]+ *$/ { print $2 } # print un-enriched IDs in list
      refs && /^- \[[0-9]+\]/ {
        gsub(/^- +/,"")
        gsub(/^\[/,"")
        gsub(/\].*/,"")
        print
      }
      /^# [Rr]elated/ { refs = 1 }
    ' $arg
    ;;
  search) # fuzzy search with optional content filter
    if [ -z "$query" ]; then
      query="$arg"
    fi
    if [ 0 != "$makeedit" ]; then
      $prog find -q "$query" | fzf -m --preview="$prog preview -f {} 2>/dev/null" | awk '{print $1}' | xargs $EDITOR -p # does this work in normal vim?
    else
      $prog find -q "$query" | fzf -m --preview="$prog preview -f {} 2>/dev/null"
    fi
    ;;
  find) # full content search
    if [ -z "$query" ]; then
      query="$arg"
    fi
    find zet -name README.md | xargs grep "$query" | awk -F ':' '
      BEGIN { OFS="\t" }
      !seen[$1]++ {
        command = "head -n 1 " $1
        command | getline heading
        close(command)
        gsub(/^# /, "", heading)
        outkw = ""
        for (n = 2; n <= NF; n++){
          if (outkw) outkw = outkw " "
          outkw = outkw $n
        }
        print $1, heading, outkw
      }
      '
    ;;
  vilink) # visual linking # TODO: documentation
    $prog search | zet/$ZET_CMD_IMPLEMENTATION/parseids | awk '
      { arr[NR]=$0 }
      NR > 1 {
        latestid = $0
        for (n = 1; n < NR; n++) {
          previd = arr[n]
          command = (ENVIRON["prog"] " addref -t " latestid " " previd)
          #print command
          system(command)
        }
      }
    '
    ;;
  viunlink) # visual linking # TODO: documentation
    $prog search | zet/$ZET_CMD_IMPLEMENTATION/parseids | awk '
      { arr[NR]=$0 }
      NR > 1 {
        latestid = $0
        for (n = 1; n < NR; n++) {
          previd = arr[n]
          command = (ENVIRON["prog"] " unlink " latestid " " previd)
          print command
          system(command)
        }
      }
    '
    ;;
  preview)
    if [ ! -z "$filearg" ]; then
      filearg=$(echo $filearg | awk '{print $1}')
      bat --color=always "$filearg"
    fi
    ;;
  unlink)
    #arg arg2
    echo "unlinking $arg $arg2"
    [ -f "zet/$arg2/README.md" ] && sed -i "/$arg/d" zet/$arg2/README.md
    [ -f "zet/$arg/README.md" ] && sed -i "/$arg2/d" zet/$arg/README.md
    ;;
  rm)
    del_id="$arg"
    forward_id="$filearg"
    echo "$del_id -> $forward_id" > /dev/stderr
    if [ -z "$del_id" ]; then
      echo "unrecoverable error"
      exit 1
    fi
    if [ -z "$forward_id" ]; then
      echo "forwarding id is required to delete, pass with -f"
      exit 1
    fi
    find zet -name README.md | xargs sed -i "/$del_id/s/^.*$/- $forward_id/"
    rm -rf zet/$del_id
    #$prog enrich # don't do this automatically
    ;;
  addref)
    target="$title"
    f="zet/$target/README.md"
    d="zet/$target"
    if [ -d "$d" ]; then
      if [ -f "$f" ]; then
        sed -i -e '/^# Related/a \
' -e "/^# Related/a - $arg" "$f"
      fi
    fi
    ;;
  enrich_links_single)
    zid="$arg"
    if [ -z $"zid" ]; then
      continue
    fi
    #get references
    cd zet/$zid
    cat README.md | awk '
    pr && /^#/ { exit }
    pr { print }
    /^# [Rr]elated/ { pr = 1 }
    ' > references
    awk '
    BEGIN { seen[""] = 0 }
    BEGINFILE { delete seen ; seen[""] = 0 }
    /^- [0-9]{14} *$/ {
      id = $2
      if (seen[id]) { next }
      seen[id] = 1
      "head -n 1 ../" id "/README.md" | getline heading
      gsub(/^# ?/,"",heading)
      if (system("test -f ../" id "/README.md") == 0) {
        print "- [" id "](/zet/" id "/README.md) " heading
      }
      next
    }
    /^- \[[0-9]{14}\]/ { # parse and reprint pretty references
      temp = $0
      gsub(/^- \[/, "", temp)
      gsub(/].*$/,"", temp)
      id = temp
      if (seen[id]) { next }
      seen[id] = 1
      "head -n 1 ../" id "/README.md" | getline heading
      gsub(/^# ?/,"",heading)
      if (system("test -f ../" id "/README.md") == 0) {
        print "- [" id "](/zet/" id "/README.md) " heading
      }
      next
    }
    { print }
    ' references > references_enriched

    { awk '/^# [Rr]elated/ { exit } { print }' README.md
    echo "# Related"
    cat references_enriched
    } > README_enriched.md

    # overwrite
    mv README_enriched.md README.md
    rm references
    rm references_enriched

    cd - > /dev/null
    ;;
  fixspaces)
    id="$arg"
    tf=$(mktemp)
    zet/$ZET_CMD_IMPLEMENTATION/fixlines zet/$id/README.md > $tf
    mv "$tf" "zet/$id/README.md"
    ;;
  enrich)
    scanoutput=$(mktemp)
    find zet -name README.md | xargs zet/$ZET_CMD_IMPLEMENTATION/scanrefs > $scanoutput
    # get all tags
    tail -n 1 zet/*/README.md | awk '/^    #/' | sed -e 's/^    //g' -e 's/ /\n/g' | sort -u > all_tags

    # index tags
    rm -rf tagindex
    mkdir -p tagindex

    awk '
      BEGIN {
        ignore["assorted"] = 1
      }
      $1 == "tags" {
        for (n=3;n<=NF;n++) {
          t = $n
          gsub(/^#/,"",t)
          if (!(t in ignore)) {
            print "- [" $2 "](/zet/" $2 "/README.md)" | ("sort -u > tagindex/" t ".md")
          }
        }
      }
    ' $scanoutput

    # check backlinks
    awk '
      $1 == "backlink" {
        # link $2 to $3
        command = (ENVIRON["prog"] " addref -t " $2 " " $3)
        system ( command )
      }
      ' $scanoutput

    # rerun
    find zet -name README.md | xargs zet/$ZET_CMD_IMPLEMENTATION/scanrefs > $scanoutput

    # beautify links
    awk '$1 == "cleanup" {
      command = (ENVIRON["prog"] " enrich_links_single " $2)
      system ( command )
    }' $scanoutput

    awk '$1 == "dead" {
      print
      command = (ENVIRON["prog"] " unlink " $2 " " $3)
      system ( command )
    }' $scanoutput

    # fix spaces
    awk '
      $1 == "emptylines" {
        command = (ENVIRON["prog"] " fixspaces " $2)
        system ( command )
      }
      ' $scanoutput
    # spaces are fixed.

    #TODO: need to redo anything?

    # run every autoexec_enrich, passing in the script's full path
    find zet -executable -name autoexec_enrich | awk '
    BEGIN { FS = OFS = "/" }
    {
      file = $0
      "realpath " file | getline
      NF--
      scriptpath = $0
      "pwd" | getline
      system(file " " $0 " " scriptpath)
    }
    '
    ;;
esac
