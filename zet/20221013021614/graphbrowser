#!/bin/bash
MYID=20221013021614
IMPL=20221006032546

if [ -z "$EDITOR" ]; then
  EDITOR=$(which nvim 2>/dev/null || which vim 2>/dev/null || which vi 2>/dev/null )
fi
if [ -z "$prog" ]; then
  export prog="./zc"
fi

# running preview subprocess
if [ "$1" == "video" ]; then
  if [ "$3" == "stat" ]; then
    zet/$IMPL/previewgit
  else
    bat --color=always $2
  fi
  exit 0
fi

# TODO: can replace all ./zc with $prog ?
# main loop
going=1
export prevdoc="README.md" # quick way to fix a bug before it happens
export doc="README.md"
if [ ! -z "$1" ]; then
  export doc="$1"
fi
selection=$(mktemp)
attachments=$(mktemp)
while [ 1 == "$going" ]; do
  id="$doc" # get id here too for fzf history
  if [[ "$doc" =~ zet/[0-9]+ ]]; then
    id=$(echo "$doc" | awk -F / '{ print $(NF-1) }')
  fi
  id=${id//\//_} # make sure there's something in this variable to save as fzf history file
  awk '
  BEGIN {
    if (ENVIRON["TMUX"] ~ /tmux/) {
      print "tab"
      print "copypath"
    }
    doc = ENVIRON["doc"]
    if (doc != "README.md") {
      id = doc
      gsub(/^zet\//,"",id)
      gsub(/\/.*$/,"",id)
      if (id != "README.md") {
        cmd = "ls zet/" id
        while ((cmd | getline) > 0) {
          print "edit", "zet/" id "/" $0
        }
        close(cmd)
        print "spawn"
        print "addtags"
      }
      print "link"
      print "unlink"
    } else {
      id = 0
      print "edit", doc
    }
    print "xfer"
    print "/deep"
    print "tagindex"
    print "~"
    print "back"
    print "enrich"
    print "stat"
    print "quit"
    fflush()
  }
  /^ *- \[.*\]\(\/zet\/[0-9]+\/README.md\)/ {
    print "goto", $0
    fflush()
  }
  ' "$doc" | fzf \
    --preview="$0 video '$doc' {}" \
    --bind "pgup:preview-up,pgdn:preview-down" \
    "--preview-window=up,75%" \
    "--history=fzftracking/$id" \
    --prompt="$doc :" > "$selection"
  sel="$(cat $selection)"
  act=$(cat $selection | awk '{print $1}')
  id=$(echo "$doc" | awk -F / '{ print $(NF-1) }')
  if [ "$act" == "quit" ]; then
    exit 0
  elif [ "$act" == "goto" ]; then
    export prevdoc="$doc"
    doc=$(awk '{
      gsub(/\).*$/,"")
      gsub(/^.*\(/,"")
      gsub(/^\//,"")
      print
    }' $selection)
    echo "changed to $doc"
  elif [ "$act" == 'tagindex' ]; then
    choice=$(ls tagindex | fzf)
    prevdoc="$doc"
    doc="tagindex/$choice"
    echo "changed to $doc"
  elif [ "$act" == '~' ]; then
    prevdoc="$doc"
    doc="README.md"
    echo "changed to $doc"
  elif [ "$act" == "unlink" ]; then
    echo "DEBUG: current id is $id"
    awk '
      /^ *- \[.*\]\(\/zet\/[0-9]+\/README.md\)/ {
        print $0
        fflush()
      }
    ' "$doc" | fzf > "$selection"
    if [ ! -z "$id" ]; then
      zet/$IMPL/parseids $selection | sort -u | xargs -n 1 $prog unlink "$id"
    fi
    #sleep 1
  elif [ "$act" == "link" ]; then
    $prog connectome -m | awk '{print $1}' > $selection
    if [ ! -z "$id" ]; then
      temp=$(mktemp)
      zet/$IMPL/parseids $selection | sort -u > $temp
      if [[ $(wc -l $temp | awk '{print $1}') != "0" ]]; then
        cat $temp | xargs -n 1 $prog addref -t "$id"
      fi
    fi
    ./zc enrich_links_single "$id"
    #sleep 1
  elif [ "$act" == "back" ]; then
    temp="$doc"
    doc="$prevdoc"
    prevdoc="$temp" # would expect back to work again?
    echo "back to $doc"
  elif [ "$act" == "edit" ]; then
    choice=$(cat $selection | awk '{print $2}')
    $EDITOR "$choice"
  elif [ "$act" == "addtags" ]; then
    selection=$(mktemp)
    ls tagindex/ | sed -e 's/\.md$//' | fzf -m > $selection
    for tag in $(cat $selection); do
      if [ ! -z "$tag" ]; then
        echo "adding tag $tag to $doc"
        sed -i -e '$s/ *$//' -e '$s/$/ #'$tag'/' "$doc"
      fi
    done
    rm "$selection"
  elif [ "$act" == "tab" ]; then
    #tmux new-window $0 "$doc"
    selection=$(mktemp)
    awk '
      /^ *- \[.*\]\(\/zet\/[0-9]+\/README.md\)/ {
        print $0
        fflush()
      }
    ' "$doc" | fzf -m | zet/$IMPL/parseids > "$selection"
    awk '{print "zet/" $0 "/README.md"}' $selection | xargs -n 1 tmux new-window "$0"
    rm "$selection"
  elif [ "$act" == "/deep" ]; then
    if [ -z $TMUX ]; then
      newid=$(zet/$MYID/connectome_deep | fzf | awk '{print $1}')
      export prevdoc="$doc"
      export doc=zet/$newid/README.md
    else
      tf=$(mktemp)
      zet/$MYID/connectome_deep | fzf -m | awk '{print $1}' | sort -u > $tf
      for f in $(cat $tf); do
        tmux new-window -n 'explore' $0 zet/$f/README.md
      done
      rm "$tf"
    fi
  elif [ "$act" == "spawn" ]; then
    id=$(echo "$doc" | awk -F / '{print $(NF-1)}')
    read -p "enter title> " title
    newid=$(./zc new -t "$title" -r "$id" | awk '/created zet ID/ { print $NF }')
    echo "spawned $newid"
    ./zc addref -t $id $newid
    ./zc enrich_links_single $id
    ./zc enrich_links_single $newid
    #TODO: add fzf menu step to select more links like workflow loop
  elif [ "$act" == "stat" ]; then
    if which lazygit; then
      lazygit
    else
      git status # i guess
      sleep 2
    fi
  elif [ "$act" == "copypath" ]; then
    echo -n "$doc" | tmux loadb -
    echo "copied $doc"
    sleep 0.5
  elif [ "$act" == "xfer" ]; then
    selection=$(mktemp)
    awk '
      /^ *- \[.*\]\(\/zet\/[0-9]+\/README.md\)/ {
        print $0
        fflush()
      }
    ' "$doc" | fzf -m | implementation/parseids | awk '
      BEGIN { c = ENVIRON["EDITOR"] " -p " ENVIRON["doc"] " " }
      /^[0-9]+/ { c = c " zet/" $0 "/README.md" }
      END { system(c) }
      '
  elif [ "$act" == "enrich" ]; then
    echo ''
    echo ' ╭────────────────────────────────┬───╮'
    echo ' │          are you sure?       ┄ │ ╳ │'
    echo ' ├────────────────────────────────┴───┤'
    echo ' │ save your changes to git first     │'
    echo ' │        answer (y/n):               │'
    echo ' │           ╔ ╕ ╖ ╗                  │'
    echo ' ╰────────────────────────────────────╯'
    echo ''
    if [ 0 == "$(git status --porcelain | wc -l)" ]; then
      answer="y"
    else
      read -p "answer (y/n): " answer
    fi
    echo "answer (y/n): $answer"
    if [ $answer == "y" ]; then
      $prog enrich
      $prog enrich
    else
      echo $answer
      sleep 1
    fi
  fi
done
rm "$selection"
